alias ls='ls --color'
alias ll='ls -lAFtr'
alias la='ls -A'
alias l='ls -CF'

alias ga='git add'
alias gc='git commit -m'

export DOTFILES=$HOME/dotfiles

function upvim() {
    cd ~/vim
    git pull
    checkyes 'run make install?'
    if [ $? -eq 0 ]; then
        ./configure  --prefix=/usr/local/ --with-features=huge --enable-multibyte --enable-gpm --enable-cscope --enable-perlinterp --enable-python3interp --enable-rubyinterp --enable-luainterp --enable-acl --enable-fontset --enable-xim --enable-terminal --enable-fail-if-missing --with-luajit --with-xi; 
        make
        sudo make install
    fi
    cd -
}
alias vm="vim $DOTFILES/.vimrc"
alias vz="vim $DOTFILES/.zshrc"
alias va="vim $DOTFILES/.zsh_aliases"
alias vl="vim ~/.zsh_local"
alias vh="sudo vim ~/.zsh_history"
function dot() {
    cd $DOTFILES
    eval $@
    if [ $# -ne 0 ]; then
        cd -
    fi
}
function dup() {
    WDIR=$PWD
    dot
    ga .
    if [ $# -ne 0 ]; then
        gc "$@"
    else
        gc "updated from $PCNAME";
    fi
    git push
    for f in `ls -ap | grep -v /`; do
        echo "$DOTFILES/$f"
        ln -sf $DOTFILES/$f $HOME/$f
    done
    source ~/.zshrc;
    cd "$WDIR"
}

alias restart="source ~/.zshrc"
alias here="explorer.exe ."
export PATH=/usr/local/texlive/2020/bin/x86_64-linux:$PATH
export PATH=$PATH:$(python3 -m site --user-base)/bin:$(python3 -m site --user-base)/share/virtualenvs
export PATH=$PATH:/home/takuto/myCommands
export INFOPATH=$INFOPATH:/usr/local/texlive/2020/texmf-dist/doc/info
export MANPATH=$MANPATH:/usr/local/texlive/2020/texmf-dist/doc/man

export PIPENV_VENV_IN_PROJECT=1
export PIPENV_NO_INHERIT=1
export PIPENV_IGNORE_VIRTUALENVS=1
export CLICOLOR=1
export HISTCONTROL=ignoreboth
# run peco with C-r
function peco-history-selection() {
    BUFFER=`history -n 1 | tac  | awk '!a[$0]++' | peco`
    CURSOR=$#BUFFER
    zle reset-prompt
}
zle -N peco-history-selection
bindkey '^R' peco-history-selection

if [ x"$MYENV" = 'x' ]; then
    export MYENV='undefined';
fi
if [ x"$PCNAME" = 'x' ]; then
    export PCNAME='undefined';
fi

alias whichsh='ps -h -o comm -p $$'
function checkyes() {
    if [[ x`whichsh` = x'bash' ]]; then
        read -p "$@ [y/N]: " yn; case "$yn" in [yY]*) return 0;; *) return 1;; esac
    elif [[ x`whichsh` = x'zsh' ]]; then
        printf "$@ [y/N]: "; if read -q; then; return 0; else return 1; fi
        echo
    fi
}

alias docker="sudo docker"
alias dc="sudo docker-compose"
alias python="python3"
alias pip="pip3"
alias piplist="pip freeze | grep -v 'pkg-resources' > requirements.txt; cat requirements.txt"
alias act="source ~/.zshrc; [ -f 'bin/activate' ] && source bin/activate || source .venv/bin/activate"
function venv() {
	python3 -m venv "$@";
	cd "$@";
	source bin/activate;
	pip3 install wheel;
    pip3 install attrdict;
    piplist;
    curl "https://gist.githubusercontent.com/pysan3/d84715ea0a66f10367ee46ce99421f8b/raw/venv.gitignore" >> .gitignore
}
function pinit() {
    cmd='pipenv install'
    if [ -f requirements.txt ]; then
        checkyes 'We found a requirements.txt in your project. Do you want to reference it?'
        if [ $? -eq 0 ]; then
            echo 'Installing from requirements.txt'
            cmd=$cmd' -r requirements.txt'
        fi
    fi
    eval $cmd
    act;
    pipenv install attrdict rich;
    curl "https://gist.githubusercontent.com/pysan3/d84715ea0a66f10367ee46ce99421f8b/raw/venv.gitignore" >> .gitignore
}
function cinit() {
    rm -rf build;
    mkdir build;
    cd build;
    cmake ..;
}
function pforward() {
    ssh -fNT -L 127.0.0.1:$2:127.0.0.1:$2 $1
}
function img2eps () {
    if ! command -v 'convert' &> /dev/null; then
        sudo apt install imagemagick
    fi
    for filename in $@; do
        echo "$filename"
        name=$(echo $filename | cut -f 1 -d '.')
        convert $filename eps2:$name.eps
    done
}
function cpp () {
    for lst in "$@"; do :; done
    mkdir -p $lst
    cp $@
}
