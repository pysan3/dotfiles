export DOTFILES=$HOME/dotfiles
source "$DOTFILES/functions.zsh"

export PATH=$(python -m site --user-base)/bin:$(python -m site --user-base)/share/virtualenvs:$PATH
export PATH="$HOME"/myCommands:"$HOME"/myCommands/bin:$PATH
export PATH="$HOME"/local/bin:$PATH
export PATH=$PATH:/usr/local/texlive/2020/bin/x86_64-linux
export INFOPATH=$INFOPATH:/usr/local/texlive/2020/texmf-dist/doc/info
export MANPATH=$MANPATH:/usr/local/texlive/2020/texmf-dist/doc/man

export PIPENV_VENV_IN_PROJECT=1
export PIPENV_NO_INHERIT=1
export PIPENV_IGNORE_VIRTUALENVS=1
export CLICOLOR=1
export EDITOR='vim'

if [ x"$MYENV" = 'x' ]; then
    export MYENV='undefined';
fi
if [ x"$PCNAME" = 'x' ]; then
    export PCNAME='undefined';
fi

alias ls='ls --color=auto'
alias ll='ls -aFhl'
alias lr='ls -RFh'
alias la='ls -aFh'
alias l='ls -1F'
alias tree='tree -a -I "\.DS_Store|\.git|node_modules|vendor\/bundle" -N'
alias grep='grep --color=auto'

alias rm='echo "Im not going to let you delete me XD"; false'
alias tp='trash-put'
alias tl='trash-list'
alias tr='trash-restore'

alias g='git'
export GIT_SSH_COMMAND='ssh -i ~/.ssh/id_rsa_git -F /dev/null'
alias yay='yay --noconfirm'
alias restart="source ~/.zshrc"

alias upgradeall='for lang in py rs js rb hs; do eval upgrade$lang; done'
alias upgradepy='pipupgrade --verbose --latest --yes' # pip install pipupgrade
alias upgraders='cargo install-update --all' # cargo install cargo-update
alias upgradejs='sudo npm install -g npm && sudo npm upgrade -g'
alias upgraderb='sudo gem update'
alias upgradehs='cabal new-update' # cabal new-install --overwrite-policy=always pandoc pandoc-citeproc pandoc-crossref

alias vm="vim $DOTFILES/.vimrc"
alias vz="vim $DOTFILES/.zshrc"
alias va="vim $DOTFILES/.zsh_aliases"
alias vr="vim $DOTFILES/.zsh_rust"
alias vl="vim ~/.zsh_local"
alias vs="vim ~/.zsh_script"
alias vc="vim ~/mySecrets.env"
alias ve="vim .env"
alias vh="sudo vim ~/.zsh_history"

alias dc="docker-compose"
alias po='poetry'
alias tm="tmuxinator"
alias ttmp="tmux new-session -A -s tmp"
alias yt='youtube-dl -ci -f mp4'

alias piplist="pip freeze | grep -v 'pkg-resources' > requirements.txt; cat requirements.txt"
alias dotenv='if [[ -z "$DONT_LOAD_ENV" && -f .env ]]; then export $(grep -v "^#" .env | command tr -d " " | xargs); fi'
alias act="source ~/.zshrc; [ -f 'bin/activate' ] && source bin/activate || source .venv/bin/activate; dotenv"
alias gignore='wget -O- "https://gist.githubusercontent.com/pysan3/d84715ea0a66f10367ee46ce99421f8b/raw/venv.gitignore" >> .gitignore'
alias tasktex="cat $NCPATH/Templates/task-template.tex > "
alias papertex="cp $NCPATH/Templates/template.sty . && cat $NCPATH/Templates/paper-template.tex > "

# depends on .zsh_local
alias cbw='set -a; . ~/mySecrets.env; set +a; echo $BW_PASSWORD | bw'
alias bwpass="jq '.login' | jq -r '.password'"
alias here="$FE ."

setopt aliases

function def() {
    alias $@ || declare -f $@ || which $@
}

function dot() {
    cd $DOTFILES
    eval $@
    if [ $# -ne 0 ]; then
        cd -
    fi
}

function dup() {
    WDIR=$PWD
    dot
    g pl
    g a .
    if [ $# -ne 0 ]; then
        g ci "$@"
    else
        g ci "updated from $PCNAME";
    fi
    git push
    for f in `command ls -ap | grep -v /`; do
        echo "$DOTFILES/$f"
        ln -sf $DOTFILES/$f $HOME/$f
    done
    source ~/.zshrc;
    cd "$WDIR"
}

function syncit () {
    if ! command -v 'syncthing' &> /dev/null; then
        echo 'install syncthing'
        return
    fi
    eval "cp -v $@ ~/Sync"
}

function cpp () {
    for lst in "$@"; do :; done
    mkdir -p $lst
    cp $@
}

function timer () {
    termdown $1 && cvlc "$HOME/Music/Clock-Alarm.mp3" --play-and-exit >/dev/null 2>/dev/null
}

alias ramen='timer 150'

function appearance () {
    cat \
        <(wget -O- 'https://www.cl.cam.ac.uk/~mgk25/ucs/examples/UTF-8-demo.txt' 2> /dev/null) \
        <(wget -O- 'https://unicode.org/Public/emoji/13.0/emoji-test.txt' 2> /dev/null) \
    | less
}

function upvim() {
    cd ~/vim
    git pull
    checkyes 'run make install?'
    if [ $? -eq 0 ]; then
        ./configure  --prefix=/usr/local/ --with-features=huge --enable-multibyte --enable-gpm --enable-cscope --enable-perlinterp --enable-python3interp --enable-rubyinterp --enable-luainterp --enable-acl --enable-fontset --enable-xim --enable-terminal --enable-fail-if-missing --with-luajit --with-xi;
        make
        sudo make install
    fi
    cd -
}

function tvim() {
    if [ $# -ge 1 ]; then
        cd "$1"
    fi
    workdir=$(basename "$PWD")
    if `tmux has-session -t "$workdir" 2> /dev/null`; then
        checkyes "Found a session named $workdir. Delete?"
        if [ $? -eq 0 ]; then
            tmux kill-session -t "$workdir"
        else
            tmux attach-session -t "$workdir"
            return 0
        fi
    fi
    vimcmd="nvim"
    if [ ! -f "$PWD/.session.vim" ]; then
        vimcmd="$vimcmd ."
    fi
    tmux new-session -s "$workdir" -d
    if [ x$MYENV = xWSL ]; then
        sleep 1
    fi
    tmux send-keys -t "$workdir" "$vimcmd" ENTER
    tmux select-layout -t "$workdir" main-vertical
    tmux a -t "$workdir"
}

function venv() {
	python -m venv "$@";
	cd "$@";
	source bin/activate;
	pip install wheel;
    pip install attrdict;
    piplist;
    gignore
}

function pinit() {
    cmd='pipenv install'
    if [ -f requirements.txt ]; then
        checkyes 'Found a requirements.txt in the project. Do you want to reference it?'
        if [ $? -eq 0 ]; then
            echo 'Installing from requirements.txt'
            cmd=$cmd' -r requirements.txt'
        fi
    fi
    eval $cmd
    act;
    pipenv install attrdict rich;
    pipenv install --dev isort pylint autopep8 flake8
    gignore
    pylint --generate-rcfile > .pylintrc
}

function tinit () {
    po init
    res=$?
    po config virtualenvs.in-project true
    if [ $res -ne 0 ]; then
        checkyes '`pyproject.toml` might already exist. Do you want to install packages from it?'
        if [ $? -eq 0 ]; then
            echo 'Installing from pyproject.toml'
            po install
        fi
    elif [ -f requirements.txt ]; then
        checkyes 'Found a requirements.txt in the project. Do you want to reference it?'
        if [ $? -eq 0 ]; then
            echo 'Installing from requirements.txt'
            checkyes 'Do you want to install the strict versions?'
            strict_version=$?
            cat requirements.txt | cut -f1 -d';' | while read package; do
                if [[ x"$package" =~ ^x[#-].* ]]; then continue; fi
                if [[ x"$package" = x ]]; then continue; fi
                if [ $strict_version -ne 0 ]; then
                    package=$(echo "$package" | cut -d'=' -f1)
                fi
                po add "$package"
            done
        fi
    fi
    po add attrdict rich toml
    po add -D isort pylint autopep8 flake8
    gignore
    act
    pylint --generate-rcfile > .pylintrc
}

function cinit() {
    rm -rf build;
    mkdir build;
    cd build;
    cmake ..;
}

function pforward() {
    ssh -fNT -L 127.0.0.1:$2:127.0.0.1:$2 $1
}

function img2eps () {
    if ! command -v 'convert' &> /dev/null; then
        sudo apt install imagemagick
    fi
    for filename in $@; do
        echo "$filename"
        name=$(echo $filename | cut -f 1 -d '.')
        convert $filename eps2:$name.eps
    done
}

function ex () {
    if [ -f $1 ]; then
        case $1 in
            *.tar.bz2)  tar xjf $1  ;;
            *.tar.gz)   tar xzf $1  ;;
            *.bz2)      bunzip2 $1  ;;
            *.rar)      unrar x $1  ;;
            *.gz)       gunzip $1   ;;
            *.tar)      tar xf $1   ;;
            *.tbz2)     tar xjf $1  ;;
            *.tgz)      tar xzf $1  ;;
            *.zip)      unzip $1    ;;
            *.Z)        uncompress $1;;
            *.7z)       7z x $1     ;;
            *)          echo "'$1' cannot be extracted via ex()" ;;
        esac
    else
        echo "'$1' is not found"
    fi
}

function happ() {
    trap "echo terminated; git remote rm heroku; return" 1 2 3 15
    heroku git:remote --app $(basename -s .git `git remote get-url origin`)
    eval "heroku $@"
    echo "delete"
    git remote rm heroku
}

# run peco with C-r
function peco-history-selection() {
    BUFFER=`history -n 1 | tac  | awk '!a[$0]++' | peco --layout=bottom-up`
    CURSOR=$#BUFFER
    zle reset-prompt
}
zle -N peco-history-selection
bindkey '^R' peco-history-selection
# cdr: run peco with dir history
if [[ -n $(echo ${^fpath}/chpwd_recent_dirs(N)) && -n $(echo ${^fpath}/cdr(N)) ]]; then
    autoload -Uz chpwd_recent_dirs cdr add-zsh-hook
    add-zsh-hook chpwd chpwd_recent_dirs
    zstyle ':completion:*' recent-dirs-insert both
    zstyle ':chpwd:*' recent-dirs-default true
    zstyle ':chpwd:*' recent-dirs-max 1000
    zstyle ':chpwd:*' recent-dirs-file "$HOME/.cache/chpwd-recent-dirs"
fi
function peco-cdr () {
    local selected_dir="$(cdr -l | sed 's/^[0-9]\+ \+//' | peco --prompt="cdr >" --query "$LBUFFER")"
    if [ -n "$selected_dir" ]; then
        BUFFER="cd ${selected_dir}"
        zle accept-line
    fi
}
zle -N peco-cdr
bindkey '^E' peco-cdr

# change current dir to what is set in vifm
function vicd() {
    local dst="$(command vifm --choose-dir - .)"
    if [ -z "$dst" ]; then
        echo 'Directory picking cancelled/failed'
        return 1
    fi
    cd "$dst"
}
function vifm-call() {
    if [[ -z $BUFFER ]]; then
        # interpreted at start, not when leaving
        BUFFER="vicd"
        zle accept-line
    fi
}
zle -N vifm-call
bindkey '^w' vifm-call

